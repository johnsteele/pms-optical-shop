package greewood.persistence;

import greenwood.patients.model.Patient;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.List;
import java.util.Properties;

/**
 * A class for connecting to the database, and interacting with it.
 * 
 * @author John Steele
 */
public class PersistenceConnection {
	
	public static void main (String[] args) throws SQLException {
		
		PersistenceConnection conn = new PersistenceConnection();
		
		//conn.insertPatient(new Patient());
		
		/*
		 * We commit, now any changes will be persisted to the database
		 * now.
		 */
		//conn.my_connection.commit();
		List<Patient> ps = conn.getPatients();
		
		for (Patient p : ps) 
			System.out.println(p.toString());
		
		if (ps.size() <= 0) System.out.println("Nothing retrieved...");
		
		conn.shutDownDatabase();
	}
	
	
	
	
	/**
	 * PreparedStatements. It is recommended to PreparedStatements when you
	 * are repeating SQL statements. They also allow you to parameterize 
	 * variables. By using them you can increase performance (because the
	 * Derby engine does not need to recompile the SQL statement each time) 
	 * and improves security (because of Java type checking).
	 */
	private List<PreparedStatement> my_preparedStatements;
	
	/**
	 * ID's for PreparedStatements.
	 */
	private enum STATEMENT {
		UPDATE_ORDER, 
		INSERT_ORDER,
		UPDATE_PATIENT,
		INSERT_PATIENT
	};
	
	/**
	 * The database username and password.
	 */
	private static final String USERNAME = "test";
	private static final String PASSWORD = "test";
	
	/**
	 * The database connection URL.
	 */
	// URL connection protocal to use, in this case Derby via JDBC.
	private static final String PROTOCAL = "jdbc:derby:";
	// Path for the database directory.
	private static final String DATABASE_DIR = "greenwoodDB";
	// The complete URL.
	private static final String DB_URL = PROTOCAL + "//localhost:1527/" + DATABASE_DIR; 
	//private static final String DB_URL = "jdbc:derby://localhost:1527/greenwoodDB;create=true";
	
	/**
	 * The connection with the database.
	 * All queries go through this object.
	 */
	private Connection my_connection;
	
	/**
	 * The connection properties.
	 */
	private Properties my_connectionProps;
	
	/**
	 * To execute SQL statements against the database.
	 */
	private Statement my_statement;
	
	/**
	 * Executing a Statement that returns values gives a ResultSet. 
	 * This allows the application to obtain the results of a SQL Statement.
	 * 
	 * Executing a Statement automatically closes any open ResultSet 
	 * generated by an earlier execution of the statement.
	 */
	private ResultSet my_resultSet;
	
	
	/**
	 * Creates a PersistenceConnection.
	 * @throws SQLException 
	 */
	public PersistenceConnection () {
		init_properties();
		makeConnection();
		//createDBTabels();
		init_statements();
	}
	
		
	/**
	 * Initializes the database properties.
	 */
	private void init_properties () {
		my_connectionProps = new Properties();
		my_connectionProps.setProperty("user", USERNAME);
		my_connectionProps.setProperty("password", PASSWORD);
	}
	
	
	/**
	 * Creates a connection with the database.
	 * 
	 * @throws SQLException If connection fails.
	 */
	private void makeConnection () {
		
		// Establish the database connection.
		try {
			my_connection = DriverManager.getConnection(DB_URL + ";create=true", my_connectionProps);
			
			/*
			 * We want to control transactions manually. AutoCommit is on by 
			 * default in JDBC.
			 */
			my_connection.setAutoCommit(false);
			System.out.println("Connected!!");
		} catch (SQLException e) {
			System.out.println("***Failed to make connection...\n");
			System.out.flush();
			e.printStackTrace();
		}	
	}
	
	
	/**
	 * Creates the common SQL PreparedStatements used by this application.
	 */
	private void init_statements () {
		my_preparedStatements = new ArrayList<PreparedStatement>();
		
		try {
			PreparedStatement statement;
			
			// Order update.
			
			// Order insert.
			
			// Patient update.			
			
			// Patient insert.
			statement = my_connection.prepareStatement("insert into TEST.patient values (?, ?)");
			my_preparedStatements.add(statement);
			System.out.println("Created PreparedSatements...");
			
		} catch (SQLException e) {
			System.out.println("***Failed to load PreparedSatements...\n");
			System.out.flush();
			e.printStackTrace();
		}		
	}
	
	
	/**
	 * Returns a list of all the Patients in the database. The patient's
	 * orders are also retrieved and stored.
	 * 
	 * @return The list of patients in the database.
	 */
	public List<Patient> getPatients () {
		List<Patient> patients = new ArrayList<Patient>();
		
		// Execute SQL query for patients.
		try {
			my_statement = my_connection.createStatement();
			//my_statement.execute("set schema 'test'");
			my_resultSet = my_statement.executeQuery(
					"SELECT * FROM TEST.patient ORDER BY name");
					//"SELECT id, name FROM patient ORDER BY id");
			
			while (my_resultSet.next()) {
				Patient p = new Patient ();
				p.setFirstName(my_resultSet.getString("name"));
				patients.add(p);
			}
			
		} catch (SQLException e) {
			System.out.println("***Failed to create get patients Statement...\n");
			System.out.flush();
			e.printStackTrace();
		}
		
		// Execute SQL query for orders.
		
		return patients;
	}
	
	
	/**
	 * Creates the database tables. If using server/client this is only 
	 * needed once. If using embedded mode it might need to be called 
	 * every time. 
	 */
	private void createDBTabels () {
		try {
			my_statement = my_connection.createStatement();
			
			//my_statement.execute("CREATE SCHEMA EMP");
			
			
			
			// Create Person table.
			my_statement.executeUpdate("create table TEST.patient (id int, name varchar (50))");
			System.out.println("Created Patient table...");
			
		
		
			// Create Order table.
//			my_statement.execute(
//					"CREATE TABLE ORDER (ID BIGINT NOT NULL, DESCRIPTION VARCHAR(255), " +
//					"PRIMARY KEY (ID))"
//			);
		
		} catch (SQLException e) {
			System.out.println("***Failed to create Person and Table in DB...\n");
			System.out.flush();
			e.printStackTrace();
		}
	}
	
	
	/**
	 * Inserts the provided Patient into the database.
	 * 
	 * @param the_patient The patient to insert.
	 */
	public void insertPatient (Patient the_patient) {
		PreparedStatement statement = my_preparedStatements.get(0);
		
		try {
			statement.setInt(1, 22);
			statement.setString(2, "John Steele");
			statement.executeUpdate();
			
			statement.setInt(1, 22);
			statement.setString(2, "John Awo");
			statement.executeUpdate();
		} catch (SQLException e) {
			System.out.println("***Failed to insert Patient...");
			System.out.flush();
			e.printStackTrace();
		}
		
		System.out.println("Inserted Patient...");
	}
	
	
	/**
	 * Shuts down the database, not the server.
	 */
	public void shutDownDatabase () {
		
		/*
		 * This step is not vital, but it will take longer to connect
		 * next time if not because it will run its recovery code.
		 * 
		 * If you omit the path all databases will be shut down:
		 * derby:jdbc:;shutdown=true
		 * But we won't do that.
		 */
		try {
			DriverManager.getConnection(DB_URL + ";shutdown=true");
		}
		
		catch (SQLException e) {
			System.out.println("***Failed to close database: " + DB_URL);
			System.out.flush();
			e.printStackTrace();
		}
	}
}
